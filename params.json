{"name":"Muffinframework","tagline":"A Framework for creating bots.","body":"**MuffinFramework** is a library that assists you in creating automated applications. These can be bots but MuffinFramework can also be used to add Plugin functionality to an existing program, as Plugins are automated as well and do not require any direct interaction from other parts of your software.\r\n\r\n[![Build status](https://ci-beta.appveyor.com/api/projects/status/ioo76wsh9822ktfw)](https://ci-beta.appveyor.com/project/Yonom13339/muffinframework)\r\n\r\nMuffinFramework requires Microsoft Visual Studio 2010 or higher and supports the following frameworks:\r\n\r\n- .NET Framework 4 and higher\r\n- Silverlight 5\r\n\r\nPrograms using MuffinFramework will have their code split in three different \"Layers\". The Platform layer is the lowest one, then there is the Services layer and finally there comes the Muffin layer. MuffinFramework will take care of loading your classes so you don't have to write a lot of code to \"glue\" these parts together. \r\n\r\nThis allows you to spend more time writing the actual code and results in a much cleaner code base.\r\n\r\n## Quick Start guide\r\nTo start using MuffinFramework, create a new console application and add ```MuffinFramework.dll``` as a resource in visual studio.\r\nNow edit your ```Program.cs``` so it looks like this.\r\n\r\n```csharp\r\nusing System;\r\nusing MuffinFramework;\r\n\r\nclass Program\r\n{\r\n    static void Main()\r\n    {\r\n        var client = new MuffinClient();\r\n        client.Start();\r\n\r\n        Console.ReadLine();\r\n        \r\n        client.Dispose();\r\n    }\r\n}\r\n```\r\nFrom here, the created client will take care of detecting, loading and executing your Platforms, Services and Muffins. Of course you can also use MuffinFramework in all kinds of .NET Applications or add other functionality to your ```Program.cs```.\r\n\r\nNow you can continue by adding three folders to your project:\r\n\r\n- Platforms\r\n- Services\r\n- Muffins\r\n\r\nThese will hold their  ```Layer ``` classes respectively.\r\n\r\nAn example of this setup can be found in the samples section of the Framework (```SampleApplication1```).\r\n\r\nYou will find it easier to start coding by first creating a Muffin and adding Platforms/Services as the need arrives later. Below you will find templates needed to create a  ```Layer ``` class.\r\n\r\n## Layers\r\nIn MuffinFramework, you split your code in three layers. These layers each have their own purpose. Once a class inherits one of the three basic Layer classes, it will be automatically detected using MEF and there is no need to reference it anywhere in your code. By default, only the assembly calling ```MuffinClient```'s constructor will be searched for classes to load. MuffinFramework can also search through multiple assemblies. This will be explained in another section of the readme.\r\n\r\n\r\n### Muffins\r\nMuffins are the part of your program that do the actual work and they usually don't provide functions for other classes to use as they control their actions themselves. MuffinFramework's pattern is suitable for bots because it is bots that do automated actions and are not given tasks from a user. Muffins are loaded after all other layers and can access both Services and Platforms. \r\n\r\n**Template:**\r\n```csharp\r\nusing MuffinFramework.Muffin;\r\n\r\npublic class Muffin1 : Muffin\r\n{\r\n    protected override void Enable()\r\n    {\r\n        // Your code here...\r\n    }\r\n}\r\n```\r\n\r\n### Services\r\nServices function as a communication layer between Muffins and Platforms. They almost always depend on one or more platforms and enhance their functionality. Services are loaded after all Platforms are.\r\n\r\n**Template:**\r\n```csharp\r\nusing MuffinFramework.Service;\r\n\r\npublic class Service1 : Service\r\n{\r\n    protected override void Enable()\r\n    {\r\n        // Your code here...\r\n    }\r\n}\r\n```\r\n\r\n### Platforms\r\nPlatforms communicate with other external systems. This can be the console output, an IRC connection to a server or any kind of web API. Platforms establish and maintain these connections. They are the first group of classes to be loaded.\r\n\r\n**Template:**\r\n```csharp\r\nusing MuffinFramework.Platform;\r\n\r\npublic class Platform1 : Platform\r\n{\r\n    protected override void Enable()\r\n    {\r\n        // Your code here...\r\n    }\r\n}\r\n```\r\n\r\n## Accessing other layers\r\nTo consume a ```Platform```/```Service```, you must first retrieve the loaded instance from its ```Loader```.\r\n```csharp\r\nPlatform1 platform = this.PlatformLoader.Get<Platform1>();\r\n```\r\n\r\nAn example of this in action can be found in ```SampleApplication2```.\r\n\r\n ```LayerLoader<,>.Get<TType>``` returns the loaded instance of the given ```TType```. If no  ```Layer ``` can be cast to ```TType```, a ```KeyNotFoundException``` is thrown.\r\n\r\nLayerLoaders of higher layers are not available to lower ones. (Ex. you can not access ```MuffinLoader``` from a ```Service```)\r\n\r\nBe careful when querying for classes in the same layer: there is no guarantee that a  ```Layer ``` will load before another and the loading order of layers might change from time to time. Therefore you must wait for all classes in a layer to load before querying a class. ```LayerLoader<,>.EnableComplete``` event can be useful in these situations. (See ```SampleApplication3```)\r\n\r\n## Parts\r\nNot every ```Muffin```/```Service```/```Protocol``` has basic tasks to do, some of them might need to be split in smaller separate parts that work together. Parts are there for this exact purpose. Instead of having to use multiple Muffins where the process of accessing other Muffins is complicated, you can use MuffinParts. MuffinParts are activated by a Muffin or another ```MuffinPart```.\r\nThey require a ```TProtocol``` class or interface, this can be your main class or any other object and is provided by the creator of the ```MuffinPart```. This object will then be stored in the ```MuffinPart.Host``` property.\r\n\r\nTo create a part, inherit from ```MuffinPart<TProtocol>```/```ServicePart<TProtocol>```/```PlatformPart<TProtocol>``` instead of  the base classes. As the type parameter  ```TProtocol ```, you can use your main  ```Layer ``` class (e.g. ```MuffinPart<Muffin1>```). Everything else will be the same as working with normal  ```Layer ``` classes.\r\n\r\nParts are not initialized by MuffinFramework automatically and must be \"Enabled\" by another class. This class can be a  ```Layer ``` or even another  ```LayerPart ```.\r\n\r\nThe following syntax can be used for this purpose:\r\n```csharp\r\nLayerPart<,>.EnablePart<TPart, TProtocol>(TProtocol host);\r\n```\r\n\r\nBecause in the following example the the class calling ```EnablePart<,>(TProtocol host)``` is used as the ```TProtocol```, you can omit the host parameter. MuffinFramework will try to cast ```this``` to the given ```TProtocol```.\r\n```csharp\r\n// These are equivalent\r\nMuffinPart1 part1 = this.EnablePart<MuffinPart1, Muffin1>(this);\r\nMuffinPart1 part2 = this.EnablePart<MuffinPart1, Muffin1>();\r\n```\r\n\r\nIf you want to avoid having to specify ```TProtocol``` every time you enable a part, change your main class so it inherits from ```Muffin<TProtocol>```/```Service<TProtocol>```/```Platform<TProtocol>```. \r\n\r\n```csharp\r\npublic class Muffin1 : Muffin<Muffin1>\r\n```\r\nNow you can omit the second type parameter for ```EnablePart```.\r\n\r\n```csharp\r\n// These are equivalent as well\r\nMuffinPart1 part1 = this.EnablePart<MuffinPart1>(this);\r\nMuffinPart1 part2 = this.EnablePart<MuffinPart1>();\r\n```\r\nFor more help, take a look at ```SampleApplication4``` which contains some usage examples.\r\n\r\n## IDisposable support\r\nAll three base classes ```Muffin```, ```Service``` and ```Platform``` and also the three part classes ```MuffinPart```, ```ServicePart``` and ```PlatformPart``` implement ```IDisposable```. \r\n```MuffinClient.Dispose()``` will dispose all  ```Layer ``` classes loaded by MuffinFramework in the following order: Muffins, then Services and finally the Platforms. It is recommended to call this function before exiting so that  ```Layer ``` classes can rely on  ```Dispose() ``` for doing tasks such as saving user data, gracefully closing TCP connections etc.\r\n\r\n## Managed Extensibility Framework\r\nTo load classes not located in the current assembly, you must edit ```MuffinClient.Catalog``` to add or remove catalogs. For loading classes, MuffinFramework uses MEF and you will need to reference ```System.ComponentModel.Composite``` to edit the catalog. More help for MEF catalogs can be found [here][1]. \r\n\r\nYou can also take a look at ```SampleApplication6``` which contains a separate library for its ```Muffin``` classes.\r\n  [1]: https://mef.codeplex.com/wikipage?title=Using%20Catalogs \r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}